# Семантические правила для NovaLang

## 1. **Правила типизации**

### 1.1. Статическая проверка типов

- **Правило T1:** Каждое выражение имеет определенный тип, вычисляемый на этапе компиляции
- **Правило T2:** Тип левой части присваивания должен точно совпадать с типом правой части
- **Правило T3:** Условия в `if`, `while`, `for` должны иметь тип `bool`


### 1.2. Правила совместимости типов для операторов

- **Правило T4:** Арифметические операторы (`+`, `-`, `*`, `/`, `%`, `//`) работают только с числовыми типами (`int`, `float`)
- **Правило T5:** Операторы сравнения (`==`, `!=`, `<`, `>`, `<=`, `>=`) возвращают `bool`
- **Правило T6:** Логические операторы (`and`, `or`, `not`) работают только с `bool`
- **Правило T7:** Оператор `+` может использоваться для конкатенации строк


## 2. **Правила областей видимости**

### 2.1. Иерархия областей видимости

- **Правило S1:** Вложенная область видимости имеет доступ к переменным из внешних областей
- **Правило S2:** Переменная во внутренней области видимости перекрывает (shadows) переменную с тем же именем из внешней области
- **Правило S3:** Глобальные переменные видны во всех функциях, кроме тех, где объявлена локальная переменная с тем же именем
- **Правило S6:** Каждый блок `{...}` создает новую область видимости
- **Правило S7:** Переменные, объявленные в инициализации for, видны только в теле цикла
- **Правило S8:** Переменные, объявленные в условии if/while, видны только в соответствующем блоке
- **Правило S9:** Параметры функции видны во всем теле функции


### 2.2. Время жизни переменных

- **Правило S4:** Локальные переменные уничтожаются при выходе из блока/функции
- **Правило S5:** Глобальные переменные существуют всю работу программы


## 3. **Правила функций**

### 3.1. Объявление и вызов функций

- **Правило F1:** Количество аргументов при вызове должно совпадать с количеством параметров в объявлении
- **Правило F2:** Типы аргументов должны совпадать с типами параметров
- **Правило F3:** Функция, объявленная с возвращаемым типом, отличным от `void`, должна содержать инструкцию `return` с выражением соответствующего типа
- **Правило F4:** Функция с возвращаемым типом `void` может использовать `return` без выражения или не использовать `return` вовсе
- **Правило F8:** Функция должна быть объявлена до ее использования (за исключением взаимной рекурсии)
- **Правило F11:** Функция `main` не может быть вызвана явно из кода программы
- **Правило F16:** Перегрузка функций не поддерживается - каждая функция должна иметь уникальное имя
- **Правило F17:** Функции различаются только по имени, но не по типам параметров


### 3.2. Рекурсия и параметры

- **Правило F5:** Функции могут вызывать сами себя (рекурсия)
- **Правило F6:** Функция может вызывать любую другую функцию, объявленную ранее в коде
- **Правило F7:** Для взаимной рекурсии требуется предварительное объявление (прототип)
- **Правило F9:** Рекурсивные вызовы разрешены
- **Правило F10:** Для взаимной рекурсии требуется предварительное объявление (forward declaration)
- **Правило F12:** Параметры функции создают новую область видимости
- **Правило F13:** Изменение параметра внутри функции не влияет на оригинальную переменную (передача по значению)


### 3.3. Возвращаемые значения

- **Правило F14:** Функция с возвращаемым типом `void` не может использоваться в выражениях
- **Правило F15:** Все пути выполнения в функции с не-void возвращаемым типом должны заканчиваться `return`


## 4. **Правила структур**


- **Правило ST1:** Поля структуры должны иметь уникальные имена в пределах структуры
- **Правило ST2:** При создании литерала структуры должны быть инициализированы все обязательные поля
- **Правило ST3:** Доступ к полям структуры возможен только через оператор `.`
- **Правило ST4:** Тип поля в литерале структуры должен соответствовать объявленному типу поля


## 5. **Правила управления потоком**

### 5.1. Условные конструкции (if-elif-else)

- **Правило CF1:** В конструкции `if-elif-else` выполняется только первая ветка с истинным условием
- **Правило CF2:** Ветка `else` выполняется, если ни одно из условий `if`/`elif` не истинно
- **Правило C1:** Ветка `if` всегда обязательна
- **Правило C2:** Веток `elif` может быть ноль или более
- **Правило C3:** Ветка `else` всегда должна быть последней и может быть только одна
- **Правило C4:** Условия вычисляются последовательно до первого истинного
- **Правило C10:** Конфликт висячего else разрешается в пользу ближайшего if


### 5.2. Конструкция switch

- **Правило CF6:** Выражение в `switch` должно быть целочисленного или строкового типа
- **Правило CF7:** Значения в `case` должны быть константными выражениями
- **Правило CF8:** Ветка `default` выполняется, если ни один `case` не совпал
- **Правило CF9:** После выполнения `case` управление переходит к следующему `case` (нет автоматического break)
- **Правило C5:** Выражение в `switch` должно быть дискретного типа (`int`, `str`, `bool`)
- **Правило C6:** Значения в `case` должны быть константными выражениями
- **Правило C7:** Все `case` значения должны быть уникальными в пределах одного `switch`
- **Правило C8:** Ветка `default` может быть только одна и должна быть последней
- **Правило C9:** После выполнения `case` управление "проваливается" (fall-through) на следующий `case`, если нет `break`


### 5.3. Циклические конструкции

- **Правило CF3:** `break` прерывает выполнение самого внутреннего цикла или `switch`
- **Правило CF4:** `continue` переходит к следующей итерации самого внутреннего цикла
- **Правило CF5:** `break` и `continue` могут использоваться только внутри циклов


### 5.4. Правила циклов

- **Правило L1:** Переменная, объявленная в инициализации for, видна только в теле цикла
- **Правило L2:** Выражение условия должно иметь тип `bool`
- **Правило L3:** Все три части for (инициализация, условие, обновление) являются опциональными
- **Правило L4:** Пустое условие эквивалентно `true`
- **Правило L5:** Условие вычисляется перед каждой итерацией (для while)
- **Правило L6:** Если условие ложно при первом вычислении, тело цикла не выполняется ни разу (для while)
- **Правило L7:** `break` прерывает самый внутренний цикл или switch
- **Правило L8:** `continue` переходит к следующей итерации самого внутреннего цикла
- **Правило L9:** `break` и `continue` вне цикла/switch - ошибка компиляции
- **Правило L10:** Вложенные циклы поддерживаются без ограничений
- **Правило L11:** Бесконечные циклы разрешены (например, `while (true) {...}`)
- **Правило L12:** Изменение переменной условия в теле цикла влияет на выполнение цикла
- **Правило L13:** `break` может использоваться для досрочного выхода из цикла


## 6. **Правила ввода-вывода**


- **Правило IO1:** `print` может принимать любое количество аргументов любого типа
- **Правило IO2:** `input` без аргументов читает строку из стандартного ввода
- **Правило IO3:** `input` с строковым аргументом выводит приглашение перед чтением
- **Правило IO4:** Функция `print` автоматически преобразует все аргументы в строковое представление
- **Правило IO5:** Преобразование типов в `print` следует правилам:
  - `int` → десятичное строковое представление
  - `float` → десятичное строковое представление с точкой
  - `bool` → "true" или "false"
  - `str` → остается без изменений
  - структуры → строковое представление в формате "{field1: value1, field2: value2}"

## 7. **Правила констант и переменных**


- **Правило V1:** Константа (`const`) должна быть инициализирована при объявлении
- **Правило V2:** Константа не может быть изменена после инициализации
- **Правило V3:** Переменная (`let`) может быть переприсвоена, но только значением того же типа
- **Правило V4:** Переменная должна быть инициализирована перед первым использованием


## 8. **Правила разрешения имен**


- **Правило N1:** Идентификатор должен быть объявлен перед использованием
- **Правило N2:** Не допускается множественное объявление в одной области видимости
- **Правило N3:** Порядок разрешения имен: локальная область → внешние области → глобальная область


## 9. **Правила порядка вычислений**


- **Правило E1:** Аргументы функции вычисляются слева направо
- **Правило E2:** В логических выражениях с `and`/`or` применяется short-circuit evaluation
- **Правило E4:** Порядок вычисления операндов арифметических операторов не гарантируется

