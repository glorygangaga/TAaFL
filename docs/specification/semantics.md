
# Семантические правила CPY

## 1. Структура программы

### 1.1. Организация кода
Программа на CPY имеет **единую точку входа** — функцию `main`, аналогично языкам C/C++. Все глобальные объявления должны находиться до функции `main`

**Структура программы:**
- Глобальные объявления (переменные, константы, функции)
- Обязательное объявление функции `main`, которая является точкой входа

### 1.2. Функция `main`
- **Правило M1:** Функция `main` должна быть объявлена ровно один раз
- **Правило M2:** Функция `main` всегда имеет тип `void` и не принимает аргументов
- **Правило M3:** Функция `main` является точкой входа программы

**Пример:**
```cpy
/// Глобальные объявления
const PI:float = 3.14159;

func calculate:float(radius:float) 
{
    return PI * radius * radius;
}

/// Функция main - точка входа
func main:void()
{
    let r:float = 5.0;
    let area:float = calculate(r);
    print("Площадь:", area);
}
```

---

## 2. Области видимости

### 2.1. Тип областей видимости
CPY использует **лексические (статические) области видимости**. Область видимости определяется структурой кода во время компиляции

### 2.2. Способы задания областей видимости
Области видимости создаются следующими конструкциями:
- **Функции** — каждая функция создает свою область видимости
- **Блоки кода** `{ ... }` — каждый блок создает вложенную область
- **Глобальная область** — код вне любых функций
- **Циклы for** — переменные инициализации for видны только в теле цикла
- **Условия if/elif/else** — каждая ветка создает свою область

### 2.3. Правила доступа
- **Правило S1:** Вложенная область имеет доступ к переменным из всех внешних областей
- **Правило S2:** Переменная во внутренней области перекрывает переменную с тем же именем из внешней области
- **Правило S3:** Параметры функции видны во всем теле функции
- **Правило S4:** Блок `{ ... }` создает новую область видимости

### 2.4. Время жизни переменных
- **Локальные переменные** уничтожаются при выходе из блока/функции
- **Глобальные переменные** существуют всю работу программы
- После завершения функции, ее локальные переменные **недоступны**

### 2.5. Семантические правила областей видимости
- **Правило S5:** Повторное объявление переменной в одной области видимости — **ошибка компиляции**
- **Правило S6:** Обращение к необъявленной переменной — **ошибка компиляции**
- **Правило S7:** Объявления внутри блока видимы **только до конца этого блока**
- **Правило S8:** Нельзя использовать переменную до её объявления
  
**Пример:**
```cpy
let global:int = 10;  /// Глобальная область

func test:void()
{
    let local:int = 20;  /// Локальная область функции
    if (true) 
    {
        let block:int = 30;  /// Область блока if
        print(global);   /// OK: доступ к глобальной
        print(local);    /// OK: доступ к локальной функции
    }
    /// print(block);  /// ОШИБКА: block не видна здесь
}
```

---

## 3. Уникальность имён

### 3.1. Пространства имён
CPY имеет следующие пространства имен:
1. **Пространство переменных и функций** — общее пространство
2. **Пространство ключевых слов** — зарезервированные слова

### 3.2. Правила уникальности
- **Правило N1:** В одной области видимости имя должно быть уникальным
- **Правило N2:** Имя должно быть объявлено перед использованием
- **Правило N3:** Порядок разрешения имен: локальная -> внешние -> глобальная область

### 3.3. Перекрытие имен
- **Разрешено:** перекрытие переменных внешней области (локальная переменная скрывает глобальную)
- **Запрещено:** перекрытие в одной и той же области
- **Особые случаи:**
  - Можно перекрыть встроенную функцию своей функцией (но не рекомендуется)
  - Нельзя перекрыть ключевые слова
  - Нельзя перекрыть имя типа в той же области

**Пример:**
```cpy
let x:int = 10;

func example:void()
{
    let x:int = 20;      /// OK: перекрытие глобальной x
    /// let x:int = 30;   /// ОШИБКА: повторное объявление в той же области
}
```
---

## 4. Переменные и константы

### 4.1. Объявление переменных
- **`let`:** Изменяемая переменная
- **`const`:** Неизменяемая константа

### 4.2. Правила инициализации
- **Правило V1:** Каждая переменная (`let`) и константа (`const`) **должна** быть проинициализирована при объявлении
- **Правило V2:** Переменные должны быть инициализированы перед использованием
- **Правило V3:** Обращение к неинициализированной переменной — ошибка компиляции

### 4.3. Константы
- **Правило V4:** Константы (`const`) нельзя изменять после объявления
- **Правило V5:** Попытка присвоить новое значение константе — ошибка компиляции

### 4.4. Изменяемые переменные
- **Правило V6:** Переменные (`let`) могут быть переопределены только в новой области видимости
- **Правило V7:** Присваиваемое выражение должно быть совместимо по типу с левой частью

**Пример:**
```cpy
const MAX_SIZE:int = 100;
/// MAX_SIZE = 200;  /// ОШИБКА: константу нельзя изменить

let counter:int = 0;
counter = 10;           /// OK: переменную можно изменять
/// counter = "text";   /// ОШИБКА: несовместимый тип
```

---

## 5. Типовая система

### 5.1. Основные принципы
CPY использует **строгую статическую типизацию**. Все типы определяются на этапе компиляции.

### 5.2. Совместимость типов
- **Правило T1:** Тип выражения в правой части присваивания или инициализации должен точно совпадать с типом переменной/константы
- **Правило T2:** Арифметические операторы работают только с числовыми типами (`int`, `float`)
- **Правило T3:** Логические операторы работают только с `bool`
- **Правило T4:** Условия в управляющих конструкциях должны быть типа `bool`

### 5.3. Автоматические преобразования
- **Правило T5:** Операции между `int` и `float` разрешены, результат всегда `float`
- **Правило T6:** Автоматические преобразования между другими типами запрещены
- **Правило T6:** Автоматические преобразования между типами запрещены, за исключением:
  - Преобразования `int` -> `float` в смешанных операциях
  - Неявного преобразования результата `input()` в числовые типы
      1. При присваивании в переменные типа `int` или `float`
      2. В арифметических операциях с числовыми типами
      3. В операциях сравнения с числовыми типами
  
### 5.4. Сравнения
- **Правило T7:** Сравнения возвращают тип `bool`
- **Правило T8:** Сравнения между `int` и `float` разрешены (с автоматическим преобразованием `int` -> `float`)

### 5.5. Функции преобразования
Для преобразования между типами используйте явные функции:
- `toInt()` — преобразует в `int`
- `toFloat()` — преобразует в `float`
- `toString()` — преобразует в `str`
- `toBool()` — преобразует в `bool`

**Пример:**
```cpy
let a:int = 5;
let b:float = 3.14;

let sum:float = a + b;          /// OK: автоматическое преобразование int->float
/// let text:str = a;            /// ОШИБКА: неявное преобразование
let text:str = toString(a);     /// OK: явное преобразование
```

---

## 6. Выражения и присваивания

### 6.1. Типы выражений
- Каждое выражение имеет определенный тип, вычисляемый на этапе компиляции
- Выражение может быть использовано как часть инструкции присваивания

### 6.2. Правила присваивания
- **Правило A1:** Левая часть присваивания должна быть l-value (переменная)
- **Правило A2:** Присваивание возвращает присвоенное значение
- **Правило A3:** Конструкция `x = y = 5` допустима и задаёт `y = 5`, `x = 5`

### 6.3. Типизация присваиваний
- **Правило A4:** Тип левой части присваивания должен совпадать с типом правой части, за исключением:
  - Присваивания результата `input()` в переменные типа `int` или `float`
- **Правило A5:** Константы (`const`) нельзя использовать как левую часть присваивания

**Пример:**
```cpy
let x:int = 5;
x = 10;           /// OK
/// 5 = x;         /// ОШИБКА: 5 не l-value
let y = (x = 15); /// y = 15, x = 15 (присваивание возвращает значение)
```

---

## 7. Функции

### 7.1. Способ передачи параметров
Параметры передаются **по значению**

### 7.2. Правила параметров
- **Правило F1:** Количество фактических параметров должно совпадать с количеством формальных
- **Правило F2:** Типы фактических параметров должны совпадать с типами формальных
- **Правило F3:** Параметры создают новую область видимости в функции
- **Правило F4:** Параметр можно переопределять внутри функции (он ведет себя как локальная переменная)
- **Правило F5:** Изменение параметра внутри функции не влияет на оригинальную переменную

### 7.3. Порядок вычисления аргументов
Аргументы вычисляются **слева направо** перед вызовом функции

### 3.4. Возврат из функций
- **Правило F6:** Функция с возвращаемым типом (не `void`) должна завершаться `return` с выражением
- **Правило F7:** Функция с типом `void` может не иметь `return` или иметь `return` без выражения
- **Правило F8:** Все пути выполнения в функции с возвращаемым типом должны заканчиваться `return`
- **Правило F9:** Возвращаемое значение должно быть совместимо с объявленным типом функции
- **Правило F10:** Перегрузка функций не поддерживается. В одной области видимости не может быть двух функций с одинаковым именем, даже если у них разные типы параметров
  
**Пример:**
```cpy
func add:int(a: int, b: int)
{
    return a + b;  /// Обязательно return с выражением
}

func log:void(msg: str)
{
    print(msg);
    /// Можно без return
}

func process:int(x: int)
{
    if (x > 0) 
    {
        return x * 2;
    }
    /// ОШИБКА: если x <= 0, нет return
}
```

---

## 8. Рекурсия

### 8.1. Поддержка рекурсии
CPY **полностью поддерживает рекурсию**

### 8.2. Правила рекурсии
- **Правило R1:** Функция может вызывать саму себя напрямую
- **Правило R2:** Для взаимной рекурсии требуется предварительное объявление 
- **Правило R3:** Рекурсивные вызовы имеют те же правила области видимости, что и обычные
- **Правило R4:** Стек вызовов управляется автоматически

### 8.3. Взаимная рекурсия
Для взаимной рекурсии необходимо использовать прототипы (предварительные объявления):

```cpy
/// Предварительное объявление
func isEven:bool(n: int);

func isOdd:bool(n: int)
{
    if (n == 0) 
    {
        return false;
    }
    return isEven(n - 1);  /// Вызов взаимно-рекурсивной функции
}

func isEven:bool(n: int)
{
    if (n == 0) 
    {
        return true;
    }
    return isOdd(n - 1);  /// Вызов взаимно-рекурсивной функции
}
```

---

## 9. Ветвления

### 9.1. Конструкция if-elif-else
- **Правило C1:** Условия должны быть типа `bool`
- **Правило C2:** Выполняется первая ветка с истинным условием
- **Правило C3:** Если ни одно условие не истинно и есть `else`, выполняется `else`
- **Правило C4:** Условия вычисляются последовательно
- **Правило C5:** Конфликт "висячего else" разрешается в пользу ближайшего `if`

**Пример:**
```cpy
if (x > 0) 
{
    print("положительное");
} 
elif (x < 0) 
{
    print("отрицательное");
} 
else 
{
    print("ноль");
}
```
---

## 10. Циклы

### 10.1. Цикл while
- **Правило L1:** Условие должно быть типа `bool`
- **Правило L2:** Условие вычисляется перед каждой итерацией
- **Правило L3:** Работает, пока условие истинно
- **Правило L4:** Если условие ложно изначально, тело не выполняется

**Пример:**
```cpy
let i:int = 0;
while (i < 5) 
{
    print(i);
    i++;
}
```

### 10.2. Цикл for
- **Правило L5:** Структура: `for (инициализация; условие; обновление) { тело }`
- **Правило L6:** Все части опциональны (пустое условие эквивалентно `true`)
- **Правило L7:** Переменные, объявленные в инициализации цикла `for` (например, `let i:int = 0`), имеют область видимости, ограниченную телом цикла и условием/обновлением. Вне цикла они невидимы
- **Правило L8:** Работа цикла:
  1. Выполняется инициализация
  2. Проверяется условие (если истинно -> тело, иначе -> выход)
  3. Выполняется тело
  4. Выполняется обновление
  5. Возврат к шагу 2

**Пример:**
```cpy
for (let i:int = 0; i < 5; i++)
{
    print(i);
}
```

### 10.3. Инструкции управления циклами
- **`break`:** Прерывает выполнение самого внутреннего цикла
- **`continue`:** Переходит к следующей итерации самого внутреннего цикла
- **Правило L9:** `break` и `continue` допустимы только внутри циклов
- **Правило L10:** `break` прерывает самый внутренний цикл
- **Правило L11:** `continue` переходит к следующей итерации

**Пример:**
```cpy
for (let i:int = 0; i < 10; i++) 
{
    if (i == 3) 
    {
        continue;  /// Пропустить итерацию i=3
    }
    if (i == 7)
    {
        break;     /// Выйти при i=7
    }
    print(i);
}
```

---

## 11. Ввод-вывод

### 11.1. Встроенные функции
- **`print(...)`:** Выводит значения выражений в стандартный поток вывода
- **`input()`:** Читает строку (без приглашения)
- **`input(prompt)`:** Выводит приглашение, затем читает строку

### 11.2. Правила ввода-вывода
- **Правило IO1:** `input()` всегда возвращает тип `str`
- **Правило IO2:** Функция `input()` всегда возвращает тип `str`, но разрешено неявное преобразование при присваивании числовой переменной:
  - `let x:int = input();` — допустимо (строка преобразуется в `int`)
  - `let y:float = input();` — допустимо (строка преобразуется в `float`)
  - `let z:str = input();` — допустимо (сохраняется как строка)
  - Для других типов требуется явное преобразование
  - 
- **Правило IO3:** `print()` может принимать любое количество аргументов разных типов
- **Правило IO4:** `print()` возвращает `void`

**Пример:**
```cpy
/// Допустимо прямое присваивание результата input() в числовые переменные
let age:int = input("Введите возраст: ");      /// Неявное преобразование str->int
let price:float = input("Введите цену: ");     /// Неявное преобразование str->float
let name:str = input("Введите имя: ");         /// Без преобразования

/// Для других операций с числовыми типами требуется явное преобразование
let doubled_price:float = price * 2.0;         /// OK: price уже float
let next_year_age:int = age + 1;               /// OK: age уже int

/// Использование в выражениях тоже допустимо
let total:int = 100 + input("Введите бонус: ");  /// OK: input() преобразуется в int

/// ОШИБКИ:
/// let flag:bool = input();  /// ОШИБКА: нет неявного преобразования str->bool
/// let b:bool = toBool(input());  /// OK: явное преобразование
```

## 12. Порядок вычислений

### 12.1. Общие правила
- **Правило E1:** Аргументы функций вычисляются слева направо
- **Правило E2:** Логические операторы используют short-circuit evaluation
- **Правило E3:** Порядок вычисления арифметических операндов не гарантируется
- **Правило E4:** Присваивания: правая часть вычисляется полностью перед присваиванием

### 12.2. Short-circuit evaluation
- **Логическое И (`and`):** Если левый операнд `false`, правый не вычисляется
- **Логическое ИЛИ (`or`):** Если левый операнд `true`, правый не вычисляется

**Пример:**
```cpy
func isPositive:bool(x: int) 
{
    print("Проверка числа", x);
    return x > 0;
}

if (isPositive(0) and isPositive(5)) 
{
    /// isPositive(5) не будет вызвано, так как isPositive(0) вернула false
}
```

## 13. Инструкции и разделители

### 13.1. Выполнение инструкций
- **Правило ST1:** Инструкции выполняются **последовательно** внутри функций
- **Правило ST2:** Каждая инструкция завершается точкой с запятой `;`
- **Правило ST3:** Пустая инструкция (`;`) допустима

### 13.2. Разделители инструкций
- Инструкции разделяются **точкой с запятой `;`**
- Это облегчает чтение и разбор кода
- Позволяет восстанавливать работу парсера после ошибок

**Пример:**
```cpy
let x:int = 5;  /// Инструкция 1
x = x + 1;      /// Инструкция 2
print(x);       /// Инструкция 3
;               /// Пустая инструкция (допустима)
```

## 14. Обработка ошибок

### 14.1. Типы ошибок
| Тип ошибки                             | Время обнаружения | Пример                               |
| -------------------------------------- | ----------------- | ------------------------------------ |
| Неявное преобразование типов           | Компиляция        | `let x:int = "123";`                 |
| Использование необъявленной переменной | Компиляция        | `print(undefined_var);`              |
| Повторное объявление в одной области   | Компиляция        | `let x:int = 5; let x:str = "text";` |
| Присваивание несовместимого типа       | Компиляция        | `let x:int = 5; x = "text";`         |
| Изменение константы                    | Компиляция        | `const x:int = 5; x = 10;`           |
| Неправильные типы в условии            | Компиляция        | `if (5) { ... }`                     |
| Неправильные типы операндов            | Компиляция        | `"text" + 5`                         |
| Ошибка преобразования                  | Выполнение        | `toInt("abc")`                       |
| Отсутствие return в функции            | Компиляция        | `func f:int() { }`                   |
| Возврат несовместимого типа            | Компиляция        | `func f:int() { return "text"; }`    |

### 14.2. Значения по умолчанию для глобальных переменных
При отсутствии явной инициализации глобальные переменные инициализируются значениями по умолчанию:
- `int`: 0
- `float`: 0.0
- `bool`: false
- `str`: ""

--

## 15. Сводка основных правил

### 15.1. Типовая безопасность
- Строгая статическая типизация
- Неявные преобразования запрещены (кроме int->float в операциях)
- Явные преобразования через функции `toInt()`, `toFloat()`, `toString()`, `toBool()`

### 15.2. Области видимости и имена
- Лексические области видимости
- Запрет повторного объявления в одной области
- Доступ к переменным от точки объявления до конца блока

### 15.3. Функции
- Точка входа — функция `main:void()`
- Параметры передаются по значению
- Полная поддержка рекурсии
- Требуется возврат значения в функциях с не-void типом

### 15.4. Управление потоком
- Условия должны быть типа `bool`
- Все ветви управления должны корректно завершаться
- `break` и `continue` только внутри циклов

### 15.5. Переменные и константы
- Обязательная инициализация при объявлении
- Константы неизменяемы после инициализации
- Тип переменной нельзя изменить после объявления

---
