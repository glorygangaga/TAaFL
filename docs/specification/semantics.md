
# Семантические правила NovaLang

## 1. Области видимости

### 1.1. Тип областей видимости
nova использует **лексические (статические) области видимости**. Область видимости определяется структурой кода во время компиляции.

### 1.2. Способы задания областей видимости
Области видимости создаются следующими конструкциями:
- **Функции** — каждая функция создает свою область видимости
- **Блоки кода** `{ ... }` — каждый блок создает вложенную область
- **Глобальная область** — код вне любых функций
- **Циклы for** — переменные инициализации for видны только в теле цикла
- **Условия if/elif/else** — каждая ветка создает свою область

### 1.3. Правила доступа
- **Правило S1:** Вложенная область имеет доступ к переменным из всех внешних областей
- **Правило S2:** Переменная во внутренней области перекрывает переменную с тем же именем из внешней области
- **Правило S3:** Параметры функции видны во всем теле функции
- **Правило S4:** Блок `{ ... }` создает новую область видимости

### 1.4. Время жизни переменных
- **Локальные переменные** уничтожаются при выходе из блока/функции
- **Глобальные переменные** существуют всю работу программы
- После завершения функции, ее локальные переменные **недоступны**

**Пример:**
```nova
let global:int = 10;  // Глобальная область

func test:void()
{
    let local:int = 20;  // Локальная область функции
    if (true) 
    {
        let block:int = 30;  // Область блока if
        print(global);   // OK: доступ к глобальной
        print(local);    // OK: доступ к локальной функции
    }
    // print(block);  // ОШИБКА: block не видна здесь
}
```

## 2. Уникальность имён

### 2.1. Пространства имён
nova имеет следующие пространства имен:
1. **Пространство переменных и функций** — общее пространство
2. **Пространство типов** — отдельное пространство для имен типов (структур)
3. **Пространство ключевых слов** — зарезервированные слова

### 2.2. Правила уникальности
- **Правило N1:** В одной области видимости имя должно быть уникальным
- **Правило N2:** Имя должно быть объявлено перед использованием
- **Правило N3:** Порядок разрешения имен: локальная → внешние → глобальная область

### 2.3. Перекрытие 
- **Разрешено:** перекрытие переменных внешней области (локальная переменная скрывает глобальную)
- **Запрещено:** перекрытие в одной и той же области
- **Особые случаи:**
  - Можно перекрыть встроенную функцию своей функцией (но не рекомендуется)
  - Нельзя перекрыть ключевые слова
  - Нельзя перекрыть имя типа в той же области

**Пример:**
```nova
let x:int = 10;

func example:void()
{
    let x:int = 20;      // OK: перекрытие глобальной x
    // let x:int = 30;   // ОШИБКА: повторное объявление в той же области
    
    // Перекрытие встроенной функции (не рекомендуется)
    func print:void(msg: str)
    {
        // своя реализация print
    }
}
```

## 3. Параметры функций

### 3.1. Способ передачи параметров
Параметры передаются **по значению**.

### 3.2. Правила параметров
- **Правило F1:** Количество фактических параметров должно совпадать с количеством формальных
- **Правило F2:** Типы фактических параметров должны совпадать с типами формальных
- **Правило F3:** Параметры создают новую область видимости в функции
- **Правило F4:** Параметр можно переопределять внутри функции (он ведет себя как локальная переменная)
- **Правило F5:** Изменение параметра внутри функции не влияет на оригинальную переменную

### 3.3. Порядок вычисления аргументов
Аргументы вычисляются **слева направо** перед вызовом функции.

### 3.4. Возврат из функций
- **Правило F6:** Функция с возвращаемым типом (не `void`) должна завершаться `return` с выражением
- **Правило F7:** Функция с типом `void` может не иметь `return` или иметь `return` без выражения
- **Правило F8:** Все пути выполнения в функции с возвращаемым типом должны заканчиваться `return`

**Пример:**
```nova
func add:int(a: int, b: int)
{
    return a + b;  // Обязательно return с выражением
}

func log:void(msg: str)
{
    print(msg);
    // Можно без return
}

func process:int(x: int)
{
    if (x > 0) 
    {
        return x * 2;
    }
    // ОШИБКА: если x <= 0, нет return
}
```

## 4. Рекурсия

### 4.1. Поддержка рекурсии
nova **полностью поддерживает рекурсию**.

### 4.2. Правила рекурсии
- **Правило R1:** Функция может вызывать саму себя напрямую
- **Правило R2:** Для взаимной рекурсии требуется предварительное объявление 
- **Правило R3:** Рекурсивные вызовы имеют те же правила области видимости, что и обычные
- **Правило R4:** Стек вызовов управляется автоматически

### 4.3. Взаимная рекурсия
Для взаимной рекурсии необходимо использовать прототипы (предварительные объявления):

```nova
// Предварительное объявление
func isEven:bool(n: int);

func isOdd:bool(n: int)
{
    if (n == 0) 
    {
        return false;
    }
    return isEven(n - 1);  // Вызов взаимно-рекурсивной функции
}

func isEven:bool(n: int)
{
    if (n == 0) 
    {
        return true;
    }
    return isOdd(n - 1);  // Вызов взаимно-рекурсивной функции
}
```

## 5. Ветвления

### 5.1. Условия ветвлений
- **Тип условия:** Должен быть `bool`
- **Истина:** Любое ненулевое значение или `true` !! разработчик упоминал, что true = 1, false = 0,  на подумать
- **Ложь:** `false` или `0` (для числовых типов в условиях)

### 5.2. Конструкция if-elif-else
- **Правило C1:** Выполняется первая ветка с истинным условием
- **Правило C2:** Если ни одно условие не истинно и есть `else`, выполняется `else`
- **Правило C3:** Условия вычисляются последовательно

**Пример:**
```nova
if (x > 0) 
{
    print("положительное");
} 
elif (x < 0) 
{
    print("отрицательное");
} 
else 
{
    print("ноль");
}
```

### 5.3. Конструкция switch-case
- **Правило S1:** Выражение должно быть дискретного типа (`int`, `str`, `bool`)
- **Правило S2:** Значения `case` должны быть константными выражениями
- **Правило S3:** Все значения `case` должны быть уникальными
- **Правило S4:** Есть fall-through между `case` (требуется явный `break`)
- **Правило S5:** `default` выполняется, если нет совпадения

**Пример:**
```nova
switch value 
{
    case 1:
        print("один");
        break;
    case 2:
        print("два");
        // fall-through
    case 3:
        print("два или три");
        break;
    default:
        print("другое");
}
```

## 6. Циклы

### 6.1. Цикл while
- **Условие:** Тип `bool`, вычисляется перед каждой итерацией
- **Работает:** Пока условие истинно
- **Особенность:** Если условие ложно изначально, тело не выполняется

**Пример:**
```nova
let i:int = 0;
while (i < 5) 
{
    print(i);
    i++;
}
```

### 6.2. Цикл for
- **Структура:** `for (инициализация; условие; обновление) { тело }`
- **Все части опциональны:** Пустое условие эквивалентно `true`
- **Область видимости:** Переменные инициализации видны только в теле цикла
- **Работает:**
  1. Выполняется инициализация
  2. Проверяется условие (если истинно → тело, иначе → выход)
  3. Выполняется тело
  4. Выполняется обновление
  5. Возврат к шагу 2

**Пример:**
```nova
for (let i:int = 0; i < 5; i++)
{
    print(i);
}
```

### 6.3. Инструкции управления циклами
- **`break`:** Прерывает выполнение самого внутреннего цикла или `switch`
- **`continue`:** Переходит к следующей итерации самого внутреннего цикла
- **Расположение:** Только внутри циклов (`continue`) или циклов/switch (`break`)

**Пример:**
```nova
for (let i:int = 0; i < 10; i++) 
{
    if (i == 3) 
    {
        continue;  // Пропустить 3
    }
    if (i == 7)
    {
        break;     // Выйти при i == 7
    }
    print(i);
}
```

## 7. Прочие правила

### 7.1. Присваивания
- **Левая часть:** Должна быть l-value:
  - Переменная (`x`)
  - Элемент массива (`arr[i]`)
  - Поле структуры (`obj.field`)
- **Правая часть:** Любое выражение совместимого типа
- **Результат:** Присваивание возвращает присвоенное значение

**Пример:**
```nova
let x:int = 5;
x = 10;           // OK
// 5 = x;         // ОШИБКА: 5 не l-value
let y = (x = 15); // y = 15, x = 15
```

### 7.2. Инициализация переменных
- **Правило V1:** Переменная должна быть инициализирована перед использованием
- **Правило V2:** Обращение к неинициализированной переменной — ошибка компиляции
- **Правило V3:** Глобальные переменные инициализируются значениями по умолчанию:
  - `int`: 0
  - `float`: 0.0
  - `bool`: false
  - `str`: ""

### 7.3. Константы и неизменяемость
- **`const`:** Значение не может быть изменено после инициализации
- **`let` по умолчанию:** указание изменяемой переменной
- **Попытка изменения:** Для `const` — ошибка компиляции

**Пример:**
```nova
const PI = 3.14;
// PI = 3.14159;  // ОШИБКА: константу нельзя изменить
    
```

### 7.4. Порядок вычислений
- **Аргументы функций:** Вычисляются слева направо
- **Арифметические операторы:** Порядок вычисления операндов не гарантируется
- **Присваивания:** Правая часть вычисляется полностью перед присваиванием

---
