
# Семантические правила CPY

## 1. Структура программы

### 1.1. Организация кода
Программа на CPY имеет **единую точку входа** — функцию `main`, аналогично языкам C/C++. Все глобальные объявления должны находиться до функции `main`

**Структура программы:**
- Глобальные объявления (переменные, константы, функции)
- Обязательное объявление функции `main`, которая является точкой входа

### 1.2. Функция `main`
- **Правило M1:** Функция `main` должна быть объявлена ровно один раз
- **Правило M2:** Функция `main` всегда имеет тип `void` и не принимает аргументов
- **Правило M3:** Функция `main` является точкой входа программы

**Пример:**
```cpy
/// Глобальные объявления
const PI:float = 3.14159;

func calculate:float(radius:float) 
{
    return PI * radius * radius;
}

/// Функция main - точка входа
func main:void()
{
    let r:float = 5.0;
    let area:float = calculate(r);
    print("Площадь:", area);
}
```

---

## 2. Области видимости

### 2.1. Тип областей видимости
CPY использует **лексические (статические) области видимости**. Область видимости определяется структурой кода во время компиляции

### 2.2. Способы задания областей видимости
Области видимости создаются следующими конструкциями:
- **Функции** — каждая функция создает свою область видимости
- **Блоки кода** `{ ... }` — каждый блок создает вложенную область
- **Глобальная область** — код вне любых функций
- **Циклы for** — переменные инициализации for видны только в теле цикла
- **Условия if/elif/else** — каждая ветка создает свою область

### 2.3. Правила доступа
- **Правило S1:** Вложенная область имеет доступ к переменным из всех внешних областей
- **Правило S2:** Параметры функции видны во всем теле функции
- **Правило S3:** Блок `{ ... }` создает новую область видимости

### 2.4. Время жизни переменных
- **Локальные переменные** уничтожаются при выходе из блока/функции
- **Глобальные переменные** существуют всю работу программы
- После завершения функции, ее локальные переменные **недоступны**

### 2.5. Семантические правила областей видимости
- **Правило S5:** Запрещено повторное объявление переменной в одной области видимости
- **Правило S6:** Нельзя обращаться к необъявленной переменной
- **Правило S7:** Объявления внутри блока видимы **только до конца этого блока**
- **Правило S8:** Нельзя использовать переменную до её объявления
  
**Пример:**
```cpy
let global:int = 10;  /// Глобальная область

func test:void()
{
    let local:int = 20;  /// Локальная область функции
    if (true) 
    {
        let block:int = 30;  /// Область блока if
        print(global);   /// OK: доступ к глобальной
        print(local);    /// OK: доступ к локальной функции
    }
    /// print(block);  /// ОШИБКА: block не видна здесь
}
```

---

## 3. Уникальность имён

### 3.1. Пространства имён
CPY имеет следующие пространства имен:
1. **Пространство переменных и функций** — общее пространство
2. **Пространство ключевых слов** — зарезервированные слова

### 3.2. Правила уникальности
- **Правило N1:** Во всех областях видимости имя должно быть уникальным 
- **Правило N2:** Имя должно быть объявлено перед использованием
- **Правило N3:** Порядок разрешения имен: локальная -> внешние -> глобальная область
---

## 4. Переменные и константы

### 4.1. Объявление переменных
- **`let`:** Изменяемая переменная (может быть объявлена без инициализации)
- **`const`:** Неизменяемая константа (должна быть инициализирована)

### 4.2. Правила инициализации
- **Правило V1:** Переменные (`let`) могут быть объявлены без инициализации. 
- **Правило V2:** Константы (`const`) **должны** быть проинициализированы при объявлении

### 4.3. Константы
- **Правило V3:** Константы (`const`) нельзя изменять после объявления
- **Правило V4:** Попытка присвоить новое значение константе — ошибка компиляции

### 4.4. Изменяемые переменные
- **Правило V5:** Переменные (`let`) могут быть переопределены только в новой области видимости

**Пример:**
```cpy
const MAX_SIZE:int = 100;
/// MAX_SIZE = 200;  /// ОШИБКА: константу нельзя изменить

let counter:int = 0;
counter = 10;           /// OK: переменную можно изменять
/// counter = "text";   /// ОШИБКА: несовместимый тип
```

---

## 5. Типовая система

### 5.1. Основные принципы
CPY использует **строгую типизацию**. Все типы определяются на этапе компиляции.

### 5.2. Совместимость типов
- **Правило T1:** Арифметические операторы работают только с числовыми типами (`int`, `float`)
 **Исключение:** конкатенация строк
- **Правило T2:** Логические операторы работают только с операндами типа `bool`
- **Правило T3:** Условия в управляющих конструкциях должна возвращать типа `bool` 
  
### 5.4. Сравнения
- **Правило T4:** Сравнения возвращают тип `bool`  

### 5.5. Функции преобразования
Для преобразования между типами используйте явные функции:
- `toInt()` — преобразует в `int`
- `toFloat()` — преобразует в `float`
- `toString()` — преобразует в `str`
- `toBool()` — преобразует в `bool`

**Пример:**
```cpy
let a:int = 5;
let b:float = 3.14;

/// let text:str = a;            /// ОШИБКА: неявное преобразование
let text:str = toString(a);     /// OK: явное преобразование
```

---

## 6. Выражения и присваивания

### 6.1. Типы выражений
- Выражение может быть использовано как часть инструкции присваивания 

### 6.2. Правила присваивания
- **Правило A1:** Левая часть присваивания должна быть именем переменной
- **Правило A2:** Присваивание возвращает присвоенное значение

### 6.3. Типизация присваиваний
- **Правило A3:** Константы (`const`) нельзя использовать как левую часть присваивания

**Пример:**
```cpy
let x:int = 5;
x = 10;           /// OK
let y = (x = 15); /// y = 15, x = 15 (присваивание возвращает значение)
```

---

## 7. Функции

### 7.1. Способ передачи параметров
Параметры передаются **по значению**

### 7.2. Правила параметров
- **Правило F1:** Количество фактических параметров должно совпадать с количеством формальных
- **Правило F2:** Параметры создают новую область видимости в функции
- **Правило F3:** Параметры функции являются локальными переменными `let`. К ним применимы все правила для переменных, включая запрет на повторное объявление
- **Правило F4:** Изменение параметра внутри функции не влияет на оригинальную переменную

### 7.3. Порядок вычисления аргументов
Аргументы вычисляются **слева направо** перед вызовом функции

### 7.4. Возврат из функций
- **Правило F6:** Функция с возвращаемым типом (не `void`) должна завершаться `return` с выражением
- **Правило F7:** Функция с типом `void` может не иметь `return` или иметь `return` без выражения
- **Правило F8:** Все пути выполнения в функции с возвращаемым типом должны заканчиваться `return`
- **Правило F9:** Перегрузка функций не поддерживается. В одной области видимости не может быть двух функций с одинаковым именем, даже если у них разные типы параметров
  
**Пример:**
```cpy
func add:int(a: int, b: int)
{
    return a + b;  /// Обязательно return с выражением
}

func log:void(msg: str)
{
    print(msg);
    /// Можно без return
}

func process:int(x: int)
{
    if (x > 0) 
    {
        return x * 2;
    }
    /// ОШИБКА: если x <= 0, нет return
}
```

---

## 8. Рекурсия

### 8.1. Поддержка рекурсии
CPY **полностью поддерживает рекурсию**

### 8.2. Правила рекурсии
- **Правило R1:** Функция может вызывать саму себя напрямую
- **Правило R2:** Взаимная рекурсия не поддерживается
- **Правило R3:** Рекурсивные вызовы имеют те же правила области видимости, что и обычные


## 9. Ветвления

### 9.1. Конструкция if-elif-else
- **Правило C1:** Условия должны быть типа `bool`
- **Правило C2:** Выполняется первая ветка с истинным условием
- **Правило C3:** Если ни одно условие не истинно и есть `else`, выполняется `else`
- **Правило C4:** Условия вычисляются последовательно
- **Правило C5:** Конфликт "висячего else" разрешается в пользу ближайшего `if`

**Пример:**
```cpy
if (x > 0) 
{
    print("положительное");
} 
elif (x < 0) 
{
    print("отрицательное");
} 
else 
{
    print("ноль");
}
```
---

## 10. Циклы

### 10.1. Цикл while
- **Правило L1:** Условие должно быть типа `bool`
- **Правило L2:** Условие вычисляется перед каждой итерацией
- **Правило L3:** Работает, пока условие истинно
- **Правило L4:** Если условие ложно изначально, тело не выполняется

**Пример:**
```cpy
let i:int = 0;
while (i < 5) 
{
    print(i);
    i++;
}
```

### 10.2. Цикл for
- **Правило L5:** Структура: `for (инициализация; условие; обновление) { тело }`
- **Правило L6:** Все части for(`инициализация; условие; обновление`) обязательны и внутри них поддерживаются только тип `int`
- **Правило L7:** Переменные, объявленные в инициализации цикла `for` (например, `let i:int = 0`), имеют область видимости, ограниченную телом цикла и условием/обновлением. Вне цикла они невидимы
- **Правило L9:** Работа цикла:
  1. Выполняется инициализация
  2. Проверяется условие (если истинно -> тело, иначе -> выход)
  3. Выполняется тело
  4. Выполняется обновление
  5. Возврат к шагу 2

**Пример:**
```cpy
for (let i:int = 0; i < 5; i++)
{
    print(i);
}
```

### 10.3. Инструкции управления циклами
- **`break`:** Прерывает выполнение самого внутреннего цикла
- **`continue`:** Переходит к следующей итерации самого внутреннего цикла
- **Правило L9:** `break` и `continue` допустимы только внутри циклов
- **Правило L10:** `break` прерывает самый внутренний цикл
- **Правило L11:** `continue` переходит к следующей итерации

**Пример:**
```cpy
for (let i:int = 0; i < 10; i++) 
{
    if (i == 3) 
    {
        continue;  /// Пропустить итерацию i=3
    }
    if (i == 7)
    {
        break;     /// Выйти при i=7
    }
    print(i);
}
```

---

## 11. Ввод-вывод

### 11.1. Встроенные функции
- **`print(...)`:** Выводит значения выражений в стандартный поток вывода
- **`input()`:** Читает строку (без параметров) 

### 11.2. Правила ввода-вывода
- **Правило IO1:** `input()` сразу преобразует получаемые данные в тип  `str` 
- **Правило IO2:** `print()` может принимать любое количество аргументов разных типов 
- **Правило IO3:** `print()` при выводе сразу преобразует данные в `str`
 
## 12. Порядок вычислений

### 12.1. Общие правила
- **Правило E1:** Аргументы функций вычисляются слева направо
- **Правило E2:** Логические операторы используют short-circuit evaluation
- **Правило E3:** Порядок вычисления арифметических операндов не гарантируется
- **Правило E4:** Присваивания: правая часть вычисляется полностью перед присваиванием

### 12.2. Short-circuit evaluation
- **Логическое И (`and`):** Если левый операнд `false`, правый не вычисляется
- **Логическое ИЛИ (`or`):** Если левый операнд `true`, правый не вычисляется

**Пример:**
```cpy
func isPositive:bool(x: int) 
{
    print("Проверка числа", x);
    return x > 0;
}

if (isPositive(0) and isPositive(5)) 
{
    /// isPositive(5) не будет вызвано, так как isPositive(0) вернула false
}
```

## 13. Инструкции и разделители

### 13.1. Выполнение инструкций
- **Правило ST1:** Инструкции выполняются **последовательно** внутри функций
- **Правило ST2:** Каждая инструкция завершается точкой с запятой `;`
- **Правило ST3:** Пустая инструкция (`;`) допустима

### 13.2. Разделители инструкций
- Инструкции разделяются **точкой с запятой `;`**
- Это облегчает чтение и разбор кода
- Позволяет восстанавливать работу парсера после ошибок

**Пример:**
```cpy
let x:int = 5;  /// Инструкция 1
x = x + 1;      /// Инструкция 2
print(x);       /// Инструкция 3
;               /// Пустая инструкция (допустима)
```
---
